#labels S3C6410,Toolchain,4.2.2-eabi
#讲解如何建立S3C6410的开发环境。

= 一、搭建编译环境 =

所需要的交叉编译工具链：S3C6410X Tool Chain 4.2.2 - EABI V0.0 - cross-4.2.2-eabi.tar
下载地址：
http://ldd6410.googlecode.com/files/cross-4.2.2-eabi.tar.bz2

1.解压上述工具链获得文件夹：4.2.2-eabi/
2.在/usr/local/下面创建目录arm/ (注意，最好是放到这个目录，不然在以后的编译过程中可能出现一些错误)
3.将目录4.2.2-eabi/移动到/usr/local/arm/下面
4.设置环境变量：
编辑/etc/profile文件，在文件末尾添加：
{{{
PATH="$PATH:/usr/local/arm/4.2.2-eabi/usr/bin"
export PATH
}}}
使环境变量生效，在终端输入命令： 
{{{
source /etc/profile
}}}
测试环境变量是否设置成功：
在终端输入：echo $PATH，如果输出的路径中包含了/usr/local/arm/4.2.2-eabi/usr/bin则说明环境变量设置成功
5.测试交叉编译工具链
在终端输入：arm-linux-gcc -v
显示如下：
{{{
Using built-in specs.
Target: arm-unknown-linux-gnueabi
Configured with: /home/scsuh/workplace/coffee/buildroot-20071011/toolchain_build_arm/gcc-4.2.2/configure --prefix=/usr --build=i386-pc-linux-gnu --host=i386-pc-linux-gnu --target=arm-unknown-linux-gnueabi --enable-languages=c,c++ --with-sysroot=/usr/local/arm/4.2.2-eabi/ --with-build-time-tools=/usr/local/arm/4.2.2-eabi//usr/arm-unknown-linux-gnueabi/bin --disable-__cxa_atexit --enable-target-optspace --with-gnu-ld --enable-shared --with-gmp=/usr/local/arm/4.2.2-eabi//gmp --with-mpfr=/usr/local/arm/4.2.2-eabi//mpfr --disable-nls --enable-threads --disable-multilib --disable-largefile --with-arch=armv4t --with-float=soft --enable-cxx-flags=-msoft-float
Thread model: posix
gcc version 4.2.2
}}}
说明交叉编译工具链已经安装成功。

= 二、搭建文件系统镜像制作环境 =

1.创建根文件系统目录rootfs及其子目录bin,sbin,boot,root,sys,srv,proc,usr等
2.编译busybox(所需要的源码包ldd6410/utils/busybox-1.15.1)
2.1解压源码包，进入源码目录；
2.2配置busybox：在源码目录执行make menuconfig, 如果使用默认配置则直接退出、保存，如果需要配置自己的则更改相应的选项再保存退出。
选上以下选项可以支持Tab补全功能
{{{
         Busybox Settings--->
                       Busybox Library Tuning--->
                                    [ ] Tab competion
}}}
已经支持了mount nfs功能
2.3修改源码目录的Makefile:
ARCH                     ？= $(SUBARCH)     修改为：  ARCH             ？= arm
CROSS_COMPILE   ?=                          修改为： CROSS_COMPILE   ?=  arm-linux-
2.4正式编译busybox：在源码目录执行make编译
2.5安装busybox： 执行命令 
{{{
make CONFIG_PREFIX=/***/rootfs(根文件系统目录) install
}}}
3.拷贝glibc库相关文件到根文件系统
glibc相关库文件在交叉编译工具链中已经有了，可以直接拷贝过来用
{{{
$ sudo cp /usr/local/arm/4.2.2-eabi/lib/*.so*  /***/rootfs/lib/   -d
$ sudo cp /usr/local/arm/4.2.2-eabi/usr/arm-unknown-linux-gnueabi/lib/*.so*  /***/rootfs/lib/  -d 
}}}
4.创建配置文件：
4.1创建/etc/inittab, 内容如下:
{{{
         # /etc/inittab
         ::sysinit:/etc/init.d/rcS
         ::askfirst:-/bin/sh 
         ::ctrlaltdel:/sbin/reboot
         ::shutdown:/bin/umount -a -r
 }}}
4.2创建/etc/init.d/rcS,内容如下：(创建完成后改变其属性使它可以执行sudo chmod  +x  /etc/init.d/rcS)
{{{
        #!/bin/sh(这段脚本主要用来自动生成设备文件)

        #ifconfig eth0 192.168.1.17
        mount -a
        mkdir /dev/pts
        mount -t devpts devpts /dev/pts
        echo /sbin/mdev > /proc/sys/kernel/hotplug
        mdev -s
}}}
4.3创建/etc/fstab文件，内容如下：
{{{
        # device     mount-point    type   options         dump  fsck order
        proc           /proc                  proc   defaults        0         0
        tmpfs          /tmp                  tmpfs  defaults       0         0
        sysfs          /sys                    sysfs  defaults        0         0
        tmpfs          /dev                   tmpfs  defaults       0         0
}}}
5.创建设备文件
在根文件系统的/dev目录下执行
{{{
$sudo mknod  console  c  5  1
$sudo mknod  null     c  1  3
}}}
这样我们的最基本的根文件系统就做好了。
6.测试已经制作好的根文件系统
在 PC上安装mkcramfs包，以便可以制作cramfs格式的文件
制作出根文件系统： 
{{{
$mkcramfs    /***/rootfs/       rootfs.cramfs
}}}
烧录uboot，kernel，rootfs到开发板并重启开发板
系统正常启动，并进入shell，测试成功。
7.测试基本的C程序在根文件系统的运行
在PC上写一个最简单的hello.c程序：
{{{
#include <stdio.h>

int main()
{
    printf("hello！\n");
    return 0;
}
}}}
编译程序：$arm-linux-gcc -o hello hello.c
将编译出来的hello复制到根文件系统的/bin或/sbin或/usr/bin或/usr/sbin等任一目录
重新制作根文件系统镜像rootfs.cramfs
重新烧写根文件系统镜像到开发板
重启动开发板，进入shell，执行hello程序，显示hello!
测试成功。 
=  三、内核及文件系统镜像烧写 =
内核及文件系统镜像的烧写请参考 6410 Linux User Guide.pdf
上面有详细的描述和图片
=  四、搭建内核开发环境 =
所需要的文件：LDD6410内核源代码linux-2.6.31
{{{ 
svn checkout http://ldd6410.googlecode.com/svn/trunk/ ldd6410-read-only 
}}}
解压内核源码，进入到源码目录（注意：源码必须放在不含中文的目录下，否则make APDK6410_defconfig是不能正确执行的）

在源码目录执行 $ make ldd6410_defconfig命令（此命令将arch/arm/configs下面的ldd6410_defconfig拷贝到源码目录并命名为.config，这样在编译时就正确运用了LDD6410的对应配置）
查看源码目录的.cross_compile文件，可见有如下内容：
{{{
    /usr/local/arm/4.2.2-eabi/usr/bin/arm-linux-
}}}
我们刚好将编译器装在了对应的位置，如果当时没有装在这个对应的位置，就要更改此文件内容，确保路径是一致的。
编译内核：在源码目录下执行make
获得结果：在arch/arm/boot下生成了zImage文件，这就是我们所需要的内核。
测试：将内核烧录到开发板上，重启开发板，正常进入系统，测试成功       
注：配置文件已经默认增加了对nfs的支持，配置信息如下：
{{{
CONFIG_NETWORK_FILESYSTEMS=y
CONFIG_NFS_FS=y
CONFIG_NFS_V3=y
CONFIG_NFS_V3_ACL=y
CONFIG_NFS_V4=y
CONFIG_NFS_DIRECTIO=y
CONFIG_NFSD=m
CONFIG_NFSD_V2_ACL=y
CONFIG_NFSD_V3=y
CONFIG_NFSD_V3_ACL=y
CONFIG_NFSD_V4=y
CONFIG_NFSD_TCP=y
CONFIG_ROOT_NFS=y
CONFIG_LOCKD=y
CONFIG_LOCKD_V4=y
CONFIG_EXPORTFS=m
CONFIG_NFS_ACL_SUPPORT=y
CONFIG_NFS_COMMON=y
}}}